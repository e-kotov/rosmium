#' Retrieve the bounding box of an OSM file
#'
#' By default, returns a single \code{sf::st_bbox} if exactly one header
#' bounding box is present.  If no header box exists and \code{calculate = TRUE},
#' computes the true data bounding box via \code{osmium fileinfo --extended}
#' (this reads the entire file and may be slow) and returns that.  If multiple
#' header boxes are found and \code{return_bbox_list = FALSE}, the function
#' errors and asks you to retry with \code{return_bbox_list = TRUE}.
#'
#' @param input_path String. Path to an existing OSM file.
#' @param calculate Logical(1). If \code{TRUE}, compute from data when no
#'   header bbox is present; otherwise error if missing.  Defaults to \code{FALSE}.
#' @param return_bbox_list Logical(1). If \code{TRUE}, return a \emph{list} of
#'   \code{sf::st_bbox} objects (one per header box), even if only one is found.
#'   Defaults to \code{FALSE}.
#' @param echo_cmd A logical. Whether to print the Osmium command generated by the function call to the screen.
#'   Defaults to `FALSE`.
#' @param echo A logical. Whether to print the standard output and error generated by the Osmium call to the screen.
#'   Defaults to `TRUE`.
#' @param spinner A logical. Whether to show a reassuring spinner while the Osmium call is being executed.
#'   Defaults to `TRUE`.
#' @param verbose A logical. Whether to display detailed information on the running command. Defaults to `FALSE`.
#' @param progress A logical. Whether to display a progress bar while running
#'   the command. Defaults to `FALSE`.
#'
#' @return
#' - If \code{return_bbox_list = FALSE}: a single \code{sf::st_bbox}.
#' - If \code{return_bbox_list = TRUE}: a \code{list} of \code{sf::st_bbox}.
#'
#' @examplesIf identical(tolower(Sys.getenv("NOT_CRAN")), "true")
#' pbf <- system.file("extdata/cur.osm.pbf", package = "rosmium")
#'
#' # header has one box
#' b1 <- osm_get_bbox(pbf)
#'
#' # force computing true bbox (reads entire file)
#' b2 <- osm_get_bbox(pbf, calculate = TRUE)
#'
#' # get a list of header boxes (even though there is only one)
#' L <- osm_get_bbox(pbf, return_bbox_list = TRUE)
#' @export
osm_get_bbox <- function(
  input_path,
  calculate = FALSE,
  return_bbox_list = FALSE,
  echo_cmd = FALSE,
  echo = FALSE,
  spinner = FALSE,
  verbose = FALSE,
  progress = FALSE
) {
  assert_osmium_is_installed()
  checkmate::assert_file_exists(input_path)
  checkmate::assert_logical(calculate, len = 1, any.missing = FALSE)
  checkmate::assert_logical(return_bbox_list, len = 1, any.missing = FALSE)
  checkmate::assert_logical(echo_cmd, len = 1, any.missing = FALSE)
  checkmate::assert_logical(echo, len = 1, any.missing = FALSE)
  checkmate::assert_logical(spinner, len = 1, any.missing = FALSE)
  checkmate::assert_logical(verbose, len = 1, any.missing = FALSE)
  checkmate::assert_logical(progress, len = 1, any.missing = FALSE)

  # read only header
  info <- osm_file_info(
    input_path,
    extended = FALSE,
    output = "list",
    echo_cmd = echo_cmd,
    echo = echo,
    spinner = spinner,
    verbose = verbose,
    progress = progress
  )

  boxes_raw <- info$header$boxes

  # normalize into a list of numeric[4]
  if (is.matrix(boxes_raw) && ncol(boxes_raw) == 4) {
    boxes_list <- split(boxes_raw, seq_len(nrow(boxes_raw)))
  } else if (is.list(boxes_raw)) {
    boxes_list <- boxes_raw
  } else {
    boxes_list <- list()
  }

  # filter only well‐formed vectors
  boxes_list <- Filter(function(x) is.numeric(x) && length(x) == 4, boxes_list)

  n_boxes <- length(boxes_list)

  # if user wants the list, return it immediately
  if (return_bbox_list) {
    return(
      lapply(boxes_list, function(x) {
        sf::st_bbox(
          c(xmin = x[1], ymin = x[2], xmax = x[3], ymax = x[4]),
          crs = 4326
        )
      })
    )
  }

  # not returning list: must have exactly one header box or compute
  if (n_boxes > 1) {
    stop(
      sprintf(
        "Found %d header bounding boxes; to retrieve them all, retry with return_bbox_list = TRUE.",
        n_boxes
      )
    )
  }

  # exactly one header box: return it
  if (n_boxes == 1) {
    x <- boxes_list[[1]]
    return(sf::st_bbox(
      c(xmin = x[1], ymin = x[2], xmax = x[3], ymax = x[4]),
      crs = 4326
    ))
  }

  # no header boxes
  if (!calculate) {
    stop(
      sprintf("No bounding‐box header found in '%s'.\n", input_path),
      "Use calculate = TRUE to compute the bbox from the data (this may be slow as it reads the entire file)."
    )
  }

  # compute via extended fileinfo
  info_ext <- osm_file_info(
    input_path,
    extended = TRUE,
    output = "list",
    echo_cmd = echo_cmd,
    echo = echo,
    spinner = spinner,
    verbose = verbose,
    progress = progress
  )

  data_bbox <- info_ext$data$bbox
  if (!is.numeric(data_bbox) || length(data_bbox) != 4) {
    stop("Failed to compute data bbox for file: ", input_path)
  }

  sf::st_bbox(
    c(
      xmin = data_bbox[1],
      ymin = data_bbox[2],
      xmax = data_bbox[3],
      ymax = data_bbox[4]
    ),
    crs = 4326
  )
}
