#' Concatenate OSM files
#'
#' This is a wrapper for [osmium cat](https://docs.osmcode.org/osmium/latest/osmium-cat.html). Just like the shell \code{osmium cat} command, \code{osm_cat} can take several input OSM files and concatenate them into one output file.  As a side-effect, it can also convert between formats, filter by object type, clean metadata, and set output headers.
#'
#' @param input_paths Character vector of paths to one or more existing OSM files.
#' @param output_path String. Path to the file where the result will be written.
#'   The format is inferred from the extension unless \code{output_format} is set.
#' @param object_type Character vector of object types to include.
#'   One or more of \code{"node"}, \code{"way"}, \code{"relation"},
#'   \code{"changeset"}.  Defaults to all types.
#' @param clean Character vector of attributes to clean (set to zero/empty).
#'   One or more of \code{"version"}, \code{"timestamp"},
#'   \code{"changeset"}, \code{"uid"}, \code{"user"}.
#' @param buffer_data Logical(1).  If \code{TRUE}, read all inputs into memory
#'   before writing.  Defaults to \code{FALSE}.
#' @param input_format Optional string.  Force the input format (e.g.
#'   \code{"osm"}, \code{"pbf"}, \code{"osc"}).  If \code{NULL}, autodetect.
#' @param output_format Optional string.  Force the output format (e.g.
#'   \code{"osm"}, \code{"pbf"}, \code{"osc"}).  If \code{NULL}, autodetect.
#' @param generator Optional string.  Specify the \code{generator} header
#'   (name and version) to add to the output file.
#' @param overwrite Logical(1).  If \code{TRUE}, allow overwriting an existing
#'   \code{output_path}.  Defaults to \code{FALSE}.
#' @param fsync Logical(1).  If \code{TRUE}, call \code{fsync} after writing
#'   to force flushing buffers.  Defaults to \code{FALSE}.
#' @param output_header Named character vector of additional header options.
#'   Each name is the header option and each value is the header value.
#'   If the value is \code{""}, the option will be written as \code{OPTION!}.
#'   Defaults to \code{NULL}.
#' @param echo_cmd A logical. Whether to print the Osmium command generated by the function call to the screen.
#'   Defaults to `FALSE`.
#' @param echo A logical. Whether to print the standard output and error generated by the Osmium call to the screen.
#'   Defaults to `TRUE`.
#' @param spinner A logical. Whether to show a reassuring spinner while the Osmium call is being executed.
#'   Defaults to `TRUE`.
#' @param verbose A logical. Whether to display detailed information on the running command. Defaults to `FALSE`.
#' @param progress A logical. Whether to display a progress bar while running
#'   the command. Defaults to `FALSE`.
#'
#' @return Invisibly returns the normalized path to \code{output_path}.
#'
#' @examplesIf identical(tolower(Sys.getenv("NOT_CRAN")), "true")
#' pbf <- system.file("extdata/cur.osm.pbf", package = "rosmium")
#'
#' # 1. get header bbox (an sf::st_bbox)
#' orig_bbox <- osm_get_bbox(pbf)
#'
#' # 2. split bbox in two halves by longitude
#' midx <- (orig_bbox["xmin"] + orig_bbox["xmax"]) / 2
#'
#' bbox1 <- sf::st_bbox(
#'   c(
#'     xmin = orig_bbox[["xmin"]],
#'     ymin = orig_bbox[["ymin"]],
#'     xmax = unname(midx),
#'     ymax = orig_bbox[["ymax"]]
#'   ),
#'   crs = sf::st_crs(orig_bbox)
#' )
#'
#' bbox2 <- sf::st_bbox(
#'   c(
#'     xmin = unname(midx),
#'     ymin = orig_bbox[["ymin"]],
#'     xmax = orig_bbox[["xmax"]],
#'     ymax = orig_bbox[["ymax"]]
#'   ),
#'   crs = sf::st_crs(orig_bbox)
#' )
#'
#' # 3. extract two halves
#' f1 <- extract(
#'   pbf,
#'   bbox1,
#'   tempfile(fileext = ".osm.pbf"),
#'   overwrite = TRUE,
#'   echo = FALSE,
#'   spinner = FALSE
#' )
#' f2 <- extract(
#'   pbf,
#'   bbox2,
#'   tempfile(fileext = ".osm.pbf"),
#'   overwrite = TRUE,
#'   echo = FALSE,
#'   spinner = FALSE
#' )
#'
#' # 4. concatenate
#' cat_out <- tempfile(fileext = ".osm.pbf")
#' osm_cat(c(f1, f2), cat_out, overwrite = TRUE, echo = FALSE, spinner = FALSE)
#'
#' # 5. sort, in case sorting was altered during concatenation
#' sorted_out <- tempfile(fileext = ".osm.pbf")
#' osm_sort(cat_out, sorted_out, overwrite = TRUE, echo = FALSE, spinner = FALSE)
#'
#' # 6. compute final bbox
#' final_bbox <- osm_get_bbox(sorted_out, calculate = TRUE)
#'
#' @export
osm_cat <- function(
  input_paths,
  output_path,
  object_type = c("node", "way", "relation", "changeset"),
  clean = character(),
  buffer_data = FALSE,
  input_format = NULL,
  output_format = NULL,
  generator = NULL,
  overwrite = FALSE,
  fsync = FALSE,
  output_header = NULL,
  echo_cmd = FALSE,
  echo = TRUE,
  spinner = TRUE,
  verbose = FALSE,
  progress = FALSE
) {
  assert_osmium_is_installed()
  # validate inputs
  checkmate::assert_character(input_paths, any.missing = FALSE, min.len = 1)
  for (p in input_paths) {
    checkmate::assert_file_exists(p, access = "r")
  }
  checkmate::assert_string(output_path)
  checkmate::assert_character(object_type, any.missing = FALSE)
  checkmate::assert_subset(
    object_type,
    choices = c("node", "way", "relation", "changeset")
  )
  checkmate::assert_character(clean)
  checkmate::assert_subset(
    clean,
    choices = c("version", "timestamp", "changeset", "uid", "user"),
    empty.ok = TRUE
  )
  checkmate::assert_logical(buffer_data, len = 1)
  if (!is.null(input_format)) checkmate::assert_string(input_format)
  if (!is.null(output_format)) checkmate::assert_string(output_format)
  if (!is.null(generator)) checkmate::assert_string(generator)
  checkmate::assert_logical(overwrite, len = 1)
  checkmate::assert_logical(fsync, len = 1)
  if (!is.null(output_header)) {
    checkmate::assert_character(output_header)
    checkmate::assert_named(output_header, type = "unique")
  }
  checkmate::assert_logical(echo_cmd, len = 1)
  checkmate::assert_logical(echo, len = 1)
  checkmate::assert_logical(spinner, len = 1)
  checkmate::assert_logical(verbose, len = 1)
  checkmate::assert_logical(progress, len = 1)

  # validate output path and extension
  assert_output_path_multi_ext(output_path, overwrite)

  # build command-line arguments
  clean_flags <- if (length(clean) > 0) paste0("--clean=", clean) else
    character()
  type_flags <- paste0("--object-type=", object_type)
  buffer_flag <- if (buffer_data) "--buffer-data" else character()
  input_fmt_flag <- if (!is.null(input_format))
    paste0("--input-format=", input_format) else character()
  output_fmt_flag <- if (!is.null(output_format))
    paste0("--output-format=", output_format) else character()
  generator_flag <- if (!is.null(generator))
    paste0("--generator=", generator) else character()
  overwrite_flag <- if (overwrite) "--overwrite" else character()
  fsync_flag <- if (fsync) "--fsync" else character()
  header_flags <- if (!is.null(output_header)) {
    unname(vapply(
      names(output_header),
      function(nm) {
        val <- output_header[[nm]]
        hdr <- if (nzchar(val)) paste0(nm, "=", val) else paste0(nm, "!")
        paste0("--output-header=", hdr)
      },
      character(1)
    ))
  } else character()
  verbose_flag <- if (verbose) "--verbose" else character()
  progress_flag <- if (progress) "--progress" else "--no-progress"
  output_flag <- paste0("--output=", output_path)

  args <- c(
    "cat",
    input_paths,
    clean_flags,
    type_flags,
    buffer_flag,
    input_fmt_flag,
    output_fmt_flag,
    generator_flag,
    output_flag,
    overwrite_flag,
    fsync_flag,
    header_flags,
    verbose_flag,
    progress_flag
  )

  # run osmium
  logs <- processx::run(
    "osmium",
    args,
    echo = echo,
    spinner = spinner,
    echo_cmd = echo_cmd
  )

  invisible(normalizePath(output_path))
}
