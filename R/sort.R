#' Sort OSM files
#'
#' @description{
#' #' This is a wrapper for **[`osmium sort`](https://docs.osmcode.org/osmium/latest/osmium-sort.html)**. It combines the content of one or more input files and writes a single file whose objects are strictly ordered by
#'
#' * type (node, way, relation),
#' * ID (negative IDs first, then positive, each by absolute value), and
#' * version (ascending).
#'
#' Duplicate objects are **not** removed; they are simply written in
#' sorted order. To remove duplicate objects, use [osm_merge()], but please sort all input files first.
#'
#' ## Sorting strategies
#'
#' | value         | passes | memory use                       | speed |
#' |---------------|--------|----------------------------------|-------|
#' | \code{"simple"}  *(default)* | 1      | keeps **all data in RAM** - expect roughly **10&nbsp;x** the on-disk size of a \code{.pbf} or \code{.osm.bz2} file | fastest |
#' | \code{"multipass"}          | 3      | reads nodes, ways, relations in separate passes - uses **much less RAM** | slower |
#'
#' The multipass strategy cannot be used when reading from \code{stdin}.
#'
#' ## Memory usage
#'
#' With the default \code{"simple"} strategy, \code{osmium sort}
#' stores the entire data set in main memory; the rule of thumb from
#' the manual is about 10x times the on-disk size of the input
#' file. For large extracts or limited RAM, switch to
#' \code{strategy = "multipass"}.
#'}
#' @param input_paths Character vector with paths to one or more existing
#'   OSM files.
#' @param output_path String. Path for the sorted output file.  The format is
#'   inferred from the file extension unless \code{output_format} is supplied.
#' @param strategy Character (length 1). Either \code{"simple"} (in-memory,
#'   single pass) or \code{"multipass"} (three passes, lower memory).
#' @param input_format Optional string. Force the input format
#'   (for example \code{"osm"}, \code{"pbf"}, \code{"osc"}).
#'   If \code{NULL}, the format is autodetected.
#' @param output_format Optional string. Force the output format
#'   (for example \code{"osm"}, \code{"pbf"}, \code{"osc"}).
#'   If \code{NULL}, the format is autodetected.
#' @param fsync Logical. If \code{TRUE}, call \code{fsync} after writing the
#'   output file to flush buffers.  Default \code{FALSE}.
#' @param generator Optional string. Value for the \code{generator} header
#'   field.  Default is \code{"osmium/<version>"}.
#' @param overwrite Logical. Allow an existing \code{output_path} to be
#'   overwritten.  Default \code{FALSE}.
#' @param output_header Named character vector of additional header options.
#'   Each name is a header key, each value the header value.  A value of
#'   \code{""} writes \code{OPTION!}.  Default \code{NULL}.
#' @param echo_cmd A logical. Whether to print the Osmium command generated by
#'   the function call to the screen. Defaults to `FALSE`.
#' @param echo A logical. Whether to print the standard output and error
#'   generated by the Osmium call to the screen. Defaults to `TRUE`.
#' @param spinner A logical. Whether to show a reassuring spinner while the
#'   Osmium call is being executed. Defaults to `TRUE`.
#' @param verbose A logical. Whether to display detailed information on the
#'   running command. Defaults to `FALSE`.
#' @param progress A logical. Whether to display a progress bar while running
#'   the command. Defaults to `FALSE`.
#'
#' @return Invisibly returns the normalised \code{output_path}.
#'
#' @examplesIf identical(tolower(Sys.getenv("NOT_CRAN")), "true")
#' pbf <- system.file("extdata/cur.osm.pbf", package = "rosmium")
#'
#' # Simple oneâ€‘pass sort (fastest, high RAM use)
#' out_simple <- tempfile(fileext = ".osm.pbf")
#' osm_sort(pbf, out_simple, overwrite = TRUE)
#'
#' # Multipass sort (lower RAM use)
#' out_multi <- tempfile(fileext = ".osm.pbf")
#' osm_sort(pbf, out_multi, strategy = "multipass", overwrite = TRUE)
#'
#' @export
osm_sort <- function(
  input_paths,
  output_path,
  strategy = c("simple", "multipass"),
  input_format = NULL,
  output_format = NULL,
  fsync = FALSE,
  generator = NULL,
  overwrite = FALSE,
  output_header = NULL,
  echo_cmd = FALSE,
  echo = TRUE,
  spinner = TRUE,
  verbose = FALSE,
  progress = FALSE
) {
  assert_osmium_is_installed()

  ## ---- argument validation --------------------------------------------------
  checkmate::assert_character(input_paths, any.missing = FALSE, min.len = 1)
  for (p in input_paths) checkmate::assert_file_exists(p, access = "r")
  checkmate::assert_string(output_path)

  strategy <- match.arg(strategy)
  if (!is.null(input_format)) checkmate::assert_string(input_format)
  if (!is.null(output_format)) checkmate::assert_string(output_format)
  checkmate::assert_flag(fsync)
  if (!is.null(generator)) checkmate::assert_string(generator)
  checkmate::assert_flag(overwrite)

  if (!is.null(output_header)) {
    checkmate::assert_named(output_header, type = "unique")
    checkmate::assert_character(output_header, any.missing = FALSE)
  }

  checkmate::assert_flag(echo_cmd)
  checkmate::assert_flag(echo)
  checkmate::assert_flag(spinner)
  checkmate::assert_flag(verbose)
  checkmate::assert_flag(progress)

  ## ---- output path check ----------------------------------------------------
  assert_output_path_multi_ext(output_path, overwrite)

  ## ---- build Osmium flags ---------------------------------------------------
  strat_flag <- paste0("--strategy=", strategy)
  input_flag <- if (!is.null(input_format))
    paste0("--input-format=", input_format) else character()
  output_fmt_flag <- if (!is.null(output_format))
    paste0("--output-format=", output_format) else character()
  fsync_flag <- if (fsync) "--fsync" else character()
  gen_flag <- if (!is.null(generator)) paste0("--generator=", generator) else
    character()
  overwrite_flag <- if (overwrite) "--overwrite" else character()
  header_flags <- if (!is.null(output_header)) {
    unname(vapply(
      names(output_header),
      function(nm) {
        val <- output_header[[nm]]
        hdr <- if (nzchar(val)) paste0(nm, "=", val) else paste0(nm, "!")
        paste0("--output-header=", hdr)
      },
      character(1)
    ))
  } else character()
  verbose_flag <- if (verbose) "--verbose" else character()
  progress_flag <- if (progress) "--progress" else "--no-progress"
  output_flag <- paste0("--output=", output_path)

  ## ---- assemble arguments ---------------------------------------------------
  args <- c(
    "sort",
    input_paths,
    strat_flag,
    input_flag,
    output_fmt_flag,
    fsync_flag,
    gen_flag,
    output_flag,
    overwrite_flag,
    header_flags,
    verbose_flag,
    progress_flag
  )

  ## ---- run ------------------------------------------------------------------
  processx::run(
    "osmium",
    args,
    echo = echo,
    spinner = spinner,
    echo_cmd = echo_cmd
  )

  invisible(normalizePath(output_path))
}
