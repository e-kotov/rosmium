% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cat.R
\name{osm_cat}
\alias{osm_cat}
\title{Concatenate OSM files with optional integrity checks and sorting}
\usage{
osm_cat(
  input_paths,
  output_path,
  object_type = c("node", "way", "relation", "changeset"),
  clean = character(),
  buffer_data = FALSE,
  check_integrity = c("no", "simple", "full"),
  stop_on_integrity_fail = FALSE,
  sort_before_cat = FALSE,
  input_format = NULL,
  output_format = NULL,
  generator = NULL,
  overwrite = FALSE,
  fsync = FALSE,
  output_header = NULL,
  echo_cmd = FALSE,
  echo = TRUE,
  spinner = TRUE,
  verbose = FALSE,
  progress = FALSE
)
}
\arguments{
\item{input_paths}{Character vector of one or more existing OSM files.}

\item{output_path}{String. Path to write the concatenated result.}

\item{object_type}{Character vector of types to include: one or more of
"node", "way", "relation", "changeset".  Defaults to all types.}

\item{clean}{Character vector of attributes to clean (set to zero/empty):
one or more of "version", "timestamp", "changeset",
"uid", "user".  Defaults to none.}

\item{buffer_data}{Logical(1). If \code{TRUE}, read all inputs into memory
before writing.  Defaults to \code{FALSE}.}

\item{check_integrity}{One of:
\itemize{
\item "no" (default): skip integrity checks,
\item "simple": run \code{osm_check_refs(check_relations = FALSE)},
\item "full": run \code{osm_check_refs(check_relations = TRUE)}.
}}

\item{stop_on_integrity_fail}{Logical. If \code{TRUE}, abort on failed
integrity check.  Defaults to \code{FALSE}.}

\item{sort_before_cat}{Logical. If \code{TRUE}, force-sort each input with
\code{\link[=osm_sort]{osm_sort()}} before concatenation.  Defaults to \code{FALSE}.}

\item{input_format}{Optional string to force the input format
(e.g. "osm", "pbf").  \code{NULL} to autodetect.}

\item{output_format}{Optional string to force the output format
(e.g. "osm", "pbf").  \code{NULL} to autodetect.}

\item{generator}{Optional string for the \strong{\code{--generator}} header tag.}

\item{overwrite}{Logical(1). If \code{TRUE}, allow overwriting an existing
\code{output_path}.  Defaults to \code{FALSE}.}

\item{fsync}{Logical(1). If \code{TRUE}, call \strong{\code{--fsync}} after writing.
Defaults to \code{FALSE}.}

\item{output_header}{Named character vector of additional header options:
\code{OPTION = "value"} or \code{OPTION = ""} to replicate via \verb{OPTION!}.}

\item{echo_cmd}{Logical. Whether to print the generated Osmium command.
Defaults to \code{FALSE}.}

\item{echo}{Logical. Whether to print stdout and stderr of the Osmium call.
Defaults to \code{TRUE}.}

\item{spinner}{Logical. Whether to show a spinner while running.
Defaults to \code{TRUE}.}

\item{verbose}{Logical. Whether to display detailed command info.
Defaults to \code{FALSE}.}

\item{progress}{Logical. Whether to show a progress bar.
Defaults to \code{FALSE}.}
}
\value{
Invisibly returns the normalized \code{output_path}.
}
\description{
{
Concatenates all input files and writes the result to the output file. The data is not sorted in any way but strictly copied from input to output. This is a wrapper for \strong{\href{https://docs.osmcode.org/osmium/latest/osmium-cat.html}{\verb{osmium cat}}} that can optionally (1) run referential-integrity pre-flight checks with \code{\link[=osm_check_refs]{osm_check_refs()}}, (2) force-sort each input with \code{\link[=osm_sort]{osm_sort()}}, and then (3) perform the actual concatenation.
\subsection{1. Referential-integrity checks}{

Set \code{check_integrity} to\tabular{lll}{
   value \tab what is checked \tab implementation \cr
   "no" (def.) \tab nothing \tab - \cr
   "simple" \tab \emph{nodes referenced by ways} are present \tab \code{osm_check_refs(check_relations = FALSE)} \cr
   "full" \tab additionally checks \emph{all refs in relations} \tab \code{osm_check_refs(check_relations = TRUE)} \cr
}


If any check returns exit-status \code{1} (missing refs) \strong{and}
\code{stop_on_integrity_fail = TRUE}, the function \strong{aborts} before concatenating.
}

\subsection{2. Optional force-sort step}{

If \code{sort_before_cat = TRUE}, each input file is first piped through
\code{\link[=osm_sort]{osm_sort()}} (strategy = "simple") into a temporary file.  Temporary
files are cleaned up at the end of the R session.  If you need permanent,
sorted copies, call \code{\link[=osm_sort]{osm_sort()}} yourself and set the desired output path.
}

\subsection{3. Memory usage during concatenation}{

\verb{osmium cat} itself uses minimal buffers, but the optional sorting step
can dominate RAM usage (up to ~10x on-disk size).
}
}
}
\examples{
\dontshow{if (identical(tolower(Sys.getenv("NOT_CRAN")), "true")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
pbf <- system.file("extdata/cur.osm.pbf", package = "rosmium")

# 1. get header bbox (an sf::st_bbox)
orig_bbox <- osm_get_bbox(pbf)

# 2. split bbox in two halves by longitude
midx <- (orig_bbox["xmin"] + orig_bbox["xmax"]) / 2

bbox1 <- sf::st_bbox(
  c(
    xmin = orig_bbox[["xmin"]],
    ymin = orig_bbox[["ymin"]],
    xmax = unname(midx),
    ymax = orig_bbox[["ymax"]]
  ),
  crs = sf::st_crs(orig_bbox)
)

bbox2 <- sf::st_bbox(
  c(
    xmin = unname(midx),
    ymin = orig_bbox[["ymin"]],
    xmax = orig_bbox[["xmax"]],
    ymax = orig_bbox[["ymax"]]
  ),
  crs = sf::st_crs(orig_bbox)
)

# 3. extract two halves
f1 <- extract(
  pbf,
  bbox1,
  tempfile(fileext = ".osm.pbf"),
  overwrite = TRUE,
  echo = FALSE,
  spinner = FALSE
)
f2 <- extract(
  pbf,
  bbox2,
  tempfile(fileext = ".osm.pbf"),
  overwrite = TRUE,
  echo = FALSE,
  spinner = FALSE
)

# 4. concatenate
cat_out <- tempfile(fileext = ".osm.pbf")
osm_cat(c(f1, f2), cat_out, overwrite = TRUE, echo = FALSE, spinner = FALSE)

# 5. sort, in case sorting was altered during concatenation
sorted_out <- tempfile(fileext = ".osm.pbf")
osm_sort(cat_out, sorted_out, overwrite = TRUE, echo = FALSE, spinner = FALSE)

# 6. compute final bbox
final_bbox <- osm_get_bbox(sorted_out, calculate = TRUE)
\dontshow{\}) # examplesIf}
}
