% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cat.R
\name{osm_cat}
\alias{osm_cat}
\title{Concatenate OSM files}
\usage{
osm_cat(
  input_paths,
  output_path,
  object_type = c("node", "way", "relation", "changeset"),
  clean = character(),
  buffer_data = FALSE,
  input_format = NULL,
  output_format = NULL,
  generator = NULL,
  overwrite = FALSE,
  fsync = FALSE,
  output_header = NULL,
  echo_cmd = FALSE,
  echo = TRUE,
  spinner = TRUE,
  verbose = FALSE,
  progress = FALSE
)
}
\arguments{
\item{input_paths}{Character vector of paths to one or more existing OSM files.}

\item{output_path}{String. Path to the file where the result will be written.
The format is inferred from the extension unless \code{output_format} is set.}

\item{object_type}{Character vector of object types to include.
One or more of \code{"node"}, \code{"way"}, \code{"relation"},
\code{"changeset"}.  Defaults to all types.}

\item{clean}{Character vector of attributes to clean (set to zero/empty).
One or more of \code{"version"}, \code{"timestamp"},
\code{"changeset"}, \code{"uid"}, \code{"user"}.}

\item{buffer_data}{Logical(1).  If \code{TRUE}, read all inputs into memory
before writing.  Defaults to \code{FALSE}.}

\item{input_format}{Optional string.  Force the input format (e.g.
\code{"osm"}, \code{"pbf"}, \code{"osc"}).  If \code{NULL}, autodetect.}

\item{output_format}{Optional string.  Force the output format (e.g.
\code{"osm"}, \code{"pbf"}, \code{"osc"}).  If \code{NULL}, autodetect.}

\item{generator}{Optional string.  Specify the \code{generator} header
(name and version) to add to the output file.}

\item{overwrite}{Logical(1).  If \code{TRUE}, allow overwriting an existing
\code{output_path}.  Defaults to \code{FALSE}.}

\item{fsync}{Logical(1).  If \code{TRUE}, call \code{fsync} after writing
to force flushing buffers.  Defaults to \code{FALSE}.}

\item{output_header}{Named character vector of additional header options.
Each name is the header option and each value is the header value.
If the value is \code{""}, the option will be written as \code{OPTION!}.
Defaults to \code{NULL}.}

\item{echo_cmd}{A logical. Whether to print the Osmium command generated by the function call to the screen.
Defaults to \code{FALSE}.}

\item{echo}{A logical. Whether to print the standard output and error generated by the Osmium call to the screen.
Defaults to \code{TRUE}.}

\item{spinner}{A logical. Whether to show a reassuring spinner while the Osmium call is being executed.
Defaults to \code{TRUE}.}

\item{verbose}{A logical. Whether to display detailed information on the running command. Defaults to \code{FALSE}.}

\item{progress}{A logical. Whether to display a progress bar while running
the command. Defaults to \code{FALSE}.}
}
\value{
Invisibly returns the normalized path to \code{output_path}.
}
\description{
This is a wrapper for \href{https://docs.osmcode.org/osmium/latest/osmium-cat.html}{osmium cat}. Just like the shell \code{osmium cat} command, \code{osm_cat} can take several input OSM files and concatenate them into one output file.  As a side-effect, it can also convert between formats, filter by object type, clean metadata, and set output headers.
}
\examples{
\dontshow{if (identical(tolower(Sys.getenv("NOT_CRAN")), "true")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
pbf <- system.file("extdata/cur.osm.pbf", package = "rosmium")

# 1. get header bbox (an sf::st_bbox)
orig_bbox <- osm_get_bbox(pbf)

# 2. split bbox in two halves by longitude
midx <- (orig_bbox["xmin"] + orig_bbox["xmax"]) / 2

bbox1 <- sf::st_bbox(
  c(
    xmin = orig_bbox[["xmin"]],
    ymin = orig_bbox[["ymin"]],
    xmax = unname(midx),
    ymax = orig_bbox[["ymax"]]
  ),
  crs = sf::st_crs(orig_bbox)
)

bbox2 <- sf::st_bbox(
  c(
    xmin = unname(midx),
    ymin = orig_bbox[["ymin"]],
    xmax = orig_bbox[["xmax"]],
    ymax = orig_bbox[["ymax"]]
  ),
  crs = sf::st_crs(orig_bbox)
)

# 3. extract two halves
f1 <- extract(
  pbf,
  bbox1,
  tempfile(fileext = ".osm.pbf"),
  overwrite = TRUE,
  echo = FALSE,
  spinner = FALSE
)
f2 <- extract(
  pbf,
  bbox2,
  tempfile(fileext = ".osm.pbf"),
  overwrite = TRUE,
  echo = FALSE,
  spinner = FALSE
)

# 4. concatenate
cat_out <- tempfile(fileext = ".osm.pbf")
osm_cat(c(f1, f2), cat_out, overwrite = TRUE, echo = FALSE, spinner = FALSE)

# 5. sort, in case sorting was altered during concatenation
sorted_out <- tempfile(fileext = ".osm.pbf")
osm_sort(cat_out, sorted_out, overwrite = TRUE, echo = FALSE, spinner = FALSE)

# 6. compute final bbox
final_bbox <- osm_get_bbox(sorted_out, calculate = TRUE)
\dontshow{\}) # examplesIf}
}
